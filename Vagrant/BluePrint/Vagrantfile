require 'yaml'

begin
  yaml_path = File.expand_path('config.yaml', __dir__)
  yaml_config = YAML.load_file(yaml_path)
rescue => e
  puts "Error loading config.yaml: #{e.message}"
  exit 1
end

n =  yaml_config["node_count"].to_i
NODES = []

# Create an array of nodes based on the node count from the config file
(1..n).each do |i|
  NODES << {
    :hostname =>  yaml_config["host_prefix"] + i.to_s,
    :ip => yaml_config["ip_prefix"] + i.to_s
  }
end

guest_additions_installed = yaml_config["vm_box"]["guest_additions_installed"]
guest_additions_installation_script = yaml_config["vm_box"]["guest_additions_installation_script"]
if ! guest_additions_installed #&& guest_additions_installation_script != nil && File.exist?(guest_additions_installation_script)
  puts "Found guest provisioning script: #{guest_additions_installation_script}"
  guest_additions_installation_script_content =  File.read(guest_additions_installation_script)
end

# Read and store common configuration file for provisioning the nodes
all_common_config_file = yaml_config["all_common_customization_config"]
if all_common_config_file != nil && File.exist?(all_common_config_file)
  puts "Found common ALL provisioning config: #{all_common_config_file}"
  all_common_config_file_content =  File.read(all_common_config_file)
else
  puts "Common ALL provisioning config not found: #{all_common_config_file}."
  all_common_config_file_content = "echo 'Common ALL provisioning config not found.'"
end

# Read and store common provisioning files for the nodes concatenated with the common configuration file content
all_common_provision_file = yaml_config["all_common_customization_script"]
if all_common_provision_file != nil && File.exist?(all_common_provision_file)
  puts "Found common ALL provisioning script: #{all_common_provision_file}"
  all_common_provision_file_content =  all_common_config_file_content + "\n" + File.read(all_common_provision_file)
else
  puts "Common ALL provisioning script not found: #{all_common_provision_file}."
  all_common_provision_file_content = "echo 'Common ALL provisioning script not found.'"
end

# Read and store common configuration file for provisioning the nodes
common_config_file = yaml_config["common_customization_config"]
if common_config_file != nil && File.exist?(common_config_file)
  puts "Found common provisioning config: #{common_config_file}"
  common_config_file_content =  File.read(common_config_file)
else
  puts "Common provisioning config not found: #{common_config_file}."
  common_config_file_content = "echo 'Common provisioning config not found.'"
end

# Read and store common provisioning files for the nodes concatenated with the common configuration file content
common_provision_file = yaml_config["common_customization_script"]
if common_provision_file != nil && File.exist?(common_provision_file)
  puts "Found common provisioning script: #{common_provision_file}"
  common_provision_file_content =  common_config_file_content + "\n" + File.read(common_provision_file)
else
  puts "Common provisioning script not found: #{common_provision_file}."
  common_provision_file_content = "echo 'Common provisioning script not found.'"
end

# Read and store custom configuration files for provisioning the nodes
config_file = yaml_config["customization_config"]
if config_file != nil && File.exist?(config_file)
  puts "Found custom provisioning config: #{config_file}"
  config_file_content =  File.read(config_file)
else
  puts "Custom provisioning config not found: #{config_file}."
  config_file_content = "echo 'Custom provisioning config not found.'"
end

# Read and store custom provisioning files for the nodes concatenated with the configuration file content
provision_file = yaml_config["customization_script"]
if provision_file != nil && File.exist?(provision_file)
  puts "Found custom provisioning script: #{provision_file}"
  provision_file_content =  config_file_content + "\n" + File.read(provision_file)
else
  puts "Custom provisioning script not found: #{provision_file}."
  provision_file_content = "echo 'Custom provisioning script not found.'"
end

Vagrant.configure("2") do |config|
  NODES.each do |node|
    config.vm.define node[:hostname] do |server|

      # Set the hostname of each node
      server.vm.hostname = node[:hostname]

      # Configure VirtualBox settings for each VM
      server.vm.provider :virtualbox do |vb|
        vb.name    = node[:hostname]
        vb.memory = yaml_config["ram_size"].to_i
        vb.cpus = yaml_config["cpu_count"].to_i
      end

      # Set the base box and network settings for each VM
      server.vm.box = yaml_config["vm_box"]["vmbox"]
      server.vm.hostname = node[:hostname]
      case yaml_config["network_type"]
      when "public_network"
        #leaving below here, just in case. In my tests vagrant (2.4.9) would pick an appropriate adabter based on IP subnet. 
        #server.vm.network :public_network, ip: node[:ip], bridge: yaml_config["network_name"]
        server.vm.network :public_network, ip: node[:ip]
      when "private_network"
        # Vagrant picks appropriate adapter based on subnet. Even though documentation suggests virtualbox__adapter should be used to set it for private.
        server.vm.network :private_network, ip: node[:ip]
      end

      # Configure shared folders between the host and guest VMs
      #server.vm.synced_folder yaml_config["SHARED_LOCAL_point"], yaml_config["SHARED_mount_point"]

      if guest_additions_installed
        server.vm.synced_folder "../../../homelab", "/homelab"
      end

      # Provision the VM with the following shell commands:
      server.vm.provision "shell", inline: "sed -i 's/^.*PasswordAuthentication.*/PasswordAuthentication yes/g' /etc/ssh/sshd_config"
      server.vm.provision "shell", inline: "sed -i 's/^.*KbdInteractiveAuthentication.*/KbdInteractiveAuthentication yes/g' /etc/ssh/sshd_config"
      server.vm.provision "shell", inline: "echo 'PermitRootLogin yes' >> /etc/ssh/sshd_config"
      # rc-service sshd restart - for alpine Linux.
      server.vm.provision "shell", inline: "systemctl reload sshd||rc-service sshd restart"
      server.vm.provision "shell", inline: "echo -e " + "\"" + yaml_config["root_password"] + "\n" + yaml_config["root_password"] + "\"" + " | passwd root"
      
      # Execute common provisioning commands
      server.vm.provision "shell", inline: all_common_provision_file_content

      # Execute common provisioning commands
      server.vm.provision "shell", inline: common_provision_file_content

      # Execute custom provisioning commands
      server.vm.provision "shell", inline: provision_file_content

      if ! guest_additions_installed && guest_additions_installation_script != nil && File.exist?(guest_additions_installation_script) && ARGV[0] == 'up'
        server.vm.provision "shell", inline: guest_additions_installation_script_content
        puts "Writing changes to config.yaml, since the guest additions were provisioned on this environment."
        yaml_config['vm_box']['guest_additions_installed'] = true
        File.write(yaml_path, yaml_config.to_yaml)
      end
    end
  end
end

#if ! guest_additions_installed
#  puts "--- Writing changes to config.yaml, since the guest additions were provisioned on this environment."
  #yaml_config['vm_box']['guest_additions_installed'] = true
  #File.write(yaml_path, yaml_config.to_yaml)
#else
#  puts "No changes done to config.yaml, since it mentions that guest additions are already present."
#  puts "guest_additions_installed: #{guest_additions_installed}"
#end
